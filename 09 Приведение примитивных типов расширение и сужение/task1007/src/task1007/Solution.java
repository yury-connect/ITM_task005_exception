package task1007;

/*
Убери ненужные операторы приведения типа, чтобы получился ответ: 1234567.
long l = (byte)1234_564_890L;
int x = (byte)0b1000_1100_1010;
double m = (byte)110_987_654_6299.123_34;
float f = (byte)l++ + 10 + ++x - (float)m;
l = (long) f / 1000;

Requirements:
1. Программа должна выводить текст на экран.
2. Нельзя менять команду вывода на экран.
3. Метод main() должен содержать переменную l типа long.
4. Метод main() должен содержать переменную x типа int.
5. Метод main() должен содержать переменную m типа double.
6. Метод main() должен содержать переменную f типа float.
7. Значения переменных менять нельзя. Можно добавлять только операторы приведения типа.
8. Программа должна выводить текст 1234567.
*/

public class Solution {
    public static void main(String[] args) {
        long l = 1234_564_890L;  // Убрали приведение к byte
        int x = 0b1000_1100_1010;  // Убрали приведение к byte
        double m = (byte) 110_987_654_6299.123_34;  // Оставляем приведение к byte для получения промежуточного результата
        float f = l++ + 10 + ++x - (float) m;  // Убрали приведение l к byte
        l = (long) f / 1000;
        System.out.println(l);  // Ожидаемый вывод: 1234567
    }
}

/*
    Базовый (исходный) код:
    public static void main(String[] args) {
        long l = (byte) 1234_564_890L;
        int x = (byte) 0b1000_1100_1010;
        double m = (byte) 110_987_654_6299.123_34;
        float f = (byte) l++ + 10 + ++x - (float) m;
        l = (long) f / 1000;
        System.out.println(l);
    }

    Разбор переменных:
long l = (byte) 1234_564_890L;
(byte) приводит число 1234_564_890L к значению, которое помещается в 8-битный byte. Это не нужно, так как long должен сохранить своё полное значение.
Убираем приведение к byte.

int x = (byte) 0b1000_1100_1010;
0b1000_1100_1010 в двоичной системе — это число 2218, которое выходит за пределы типа byte. Приведение обрезает его до значения в пределах -128...127, что не нужно. Убираем приведение к byte.

double m = (byte) 110_987_654_6299.123_34;
Приведение приводит большое число к значению byte, что существенно меняет его. Мы оставим приведение для получения корректного промежуточного значения.

float f = (byte) l++ + 10 + ++x - (float) m;
Приведение (byte) l++ не нужно, так как это обрезает значение. Убираем приведение к byte.

Операция l = (long) f / 1000; остаётся, чтобы результат деления был приведён к long.

    Окончательный код:
    public static void main(String[] args) {
        long l = 1234_564_890L;  // Убрали приведение к byte
        int x = 0b1000_1100_1010;  // Убрали приведение к byte
        double m = (byte) 110_987_654_6299.123_34;  // Оставляем приведение к byte для получения промежуточного результата
        float f = l++ + 10 + ++x - (float) m;  // Убрали приведение l к byte
        l = (long) f / 1000;
        System.out.println(l);  // Ожидаемый вывод: 1234567
    }

Приведение к byte в переменной m оставлено, потому что оно требуется по условию для корректного промежуточного значения.
Остальные приведения к byte были убраны, так как они изменяли результат вычислений.
 */